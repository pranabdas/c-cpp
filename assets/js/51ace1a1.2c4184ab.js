"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[6257],{5162:(e,t,a)=>{a.d(t,{Z:()=>m});var n=a(7294),r=a(6010);const s={tabItem:"tabItem_Ymn6"};function m(e){let{children:t,hidden:a,className:m}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(s.tabItem,m),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>b});var n=a(7462),r=a(7294),s=a(6010),m=a(2466),p=a(6550),o=a(1980),i=a(7392),l=a(12);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function h(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,i.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function d(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function u(e){let{queryString:t=!1,groupId:a}=e;const n=(0,p.k6)(),s=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,o._X)(s),(0,r.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(n.location.search);t.set(s,e),n.replace({...n.location,search:t.toString()})}),[s,n])]}function N(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,s=h(e),[m,p]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s}))),[o,i]=u({queryString:a,groupId:n}),[c,N]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,s]=(0,l.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&s.set(e)}),[a,s])]}({groupId:n}),k=(()=>{const e=o??c;return d({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)((()=>{k&&p(k)}),[k]);return{selectedValue:m,selectValue:(0,r.useCallback)((e=>{if(!d({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);p(e),i(e),N(e)}),[i,N,s]),tabValues:s}}var k=a(2389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:a,selectedValue:p,selectValue:o,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,m.o5)(),h=e=>{const t=e.currentTarget,a=l.indexOf(t),n=i[a].value;n!==p&&(c(t),o(n))},d=e=>{let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;t=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;t=l[a]??l[l.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":a},t)},i.map((e=>{let{value:t,label:a,attributes:m}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:p===t?0:-1,"aria-selected":p===t,key:t,ref:e=>l.push(e),onKeyDown:d,onClick:h},m,{className:(0,s.Z)("tabs__item",f.tabItem,m?.className,{"tabs__item--active":p===t})}),a??t)})))}function w(e){let{lazy:t,children:a,selectedValue:n}=e;const s=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},s.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function y(e){const t=N(e);return r.createElement("div",{className:(0,s.Z)("tabs-container",f.tabList)},r.createElement(g,(0,n.Z)({},e,t)),r.createElement(w,(0,n.Z)({},e,t)))}function b(e){const t=(0,k.Z)();return r.createElement(y,(0,n.Z)({key:String(t)},e))}},120:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>l,metadata:()=>h,toc:()=>u});var n=a(7462),r=(a(7294),a(3905)),s=a(4866),m=a(5162),p=a(614);const o='#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\ntypedef struct tree\n{\n    int key;\n    struct tree *left, *right;\n} tree;\n\ntree *create_tree(int key)\n{\n    tree *node = (tree *)malloc(sizeof(tree));\n    assert(node);\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n\n    return node;\n}\n\ntree *insert_node(tree *node, int key)\n{\n    if (node == NULL)\n    {\n        return (create_tree(key));\n    }\n\n    if (key < node->key)\n    {\n        node->left = insert_node(node->left, key);\n    }\n    else if (key > node->key)\n    {\n        node->right = insert_node(node->right, key);\n    }\n\n    return node;\n}\n\nvoid print_tree(tree *node)\n{\n    if (node == NULL)\n    {\n        return;\n    }\n    else if (node->left == NULL && node->right == NULL)\n    {\n        printf("%d", node->key);\n        return;\n    }\n    else\n    {\n        printf("%d", node->key);\n\n        if (node->left != NULL && node->right != NULL)\n        {\n            printf("[");\n            print_tree(node->left);\n            printf(", ");\n            print_tree(node->right);\n            printf("]");\n        }\n        else if (node->right == NULL /* && (node->left != NULL) */)\n        {\n            printf("[");\n            print_tree(node->left);\n            printf("]");\n        }\n        else /* if (node->left == NULL && (node->left != NULL)) */\n        {\n            printf("[");\n            print_tree(node->right);\n            printf("]");\n        }\n    }\n}\n\n// depth first search\ntree *search(tree *node, int key)\n{\n    if (node == NULL || node->key == key)\n    {\n        return node;\n    }\n\n    if (key < node->key)\n    {\n        return search(node->left, key);\n    }\n    else\n    {\n        return search(node->right, key);\n    }\n}\n\n// build queue data structure\ntypedef struct queue\n{\n    struct tree *item;  // content of queue, a tree pointer\n    struct queue *next; // pointer to next queue item\n\n} queue;\n\nvoid enqueue(queue **q, tree *node)\n{\n    queue *p = *q;\n    queue *r = (queue *)malloc(sizeof(queue));\n    assert(r);\n    r->item = node;\n    r->next = NULL;\n\n    if (p == NULL)\n    {\n        *q = r; // if the queue is empty, newly allocated item is the queue\n    }\n    else\n    {\n        while (p->next) // go to the end of queue and attach new item\n        {\n            p = p->next;\n        }\n        p->next = r;\n    }\n}\n\ntree *dequeue(queue **q)\n// removes first item from queue and returns the item\n{\n    queue *p = *q;\n\n    if (p)\n    {\n        *q = p->next;\n    }\n\n    return p->item;\n}\n\nint queue_length(queue *q)\n{\n    int len = 0;\n\n    while (q)\n    {\n        q = q->next;\n        len++;\n    }\n\n    return len;\n}\n\n// breadth first traversal to print binary tree level by level\nvoid print_tree_levels(tree *root)\n{\n    int number_of_nodes;\n    if (root == NULL)\n    {\n        return;\n    }\n\n    queue *q = NULL;\n    enqueue(&q, root);\n\n    while (1)\n    {\n        number_of_nodes = queue_length(q);\n        if (number_of_nodes == 0)\n        {\n            break;\n        }\n\n        while (number_of_nodes > 0)\n        {\n            tree *node = dequeue(&q);\n            printf("%d", node->key);\n            if (number_of_nodes > 1)\n            {\n                printf(", ");\n            }\n\n            if (node->left != NULL)\n            {\n                enqueue(&q, node->left);\n            }\n\n            if (node->right != NULL)\n            {\n                enqueue(&q, node->right);\n            }\n\n            number_of_nodes--;\n        }\n        printf("\\n");\n    }\n}\n\nint main()\n{\n    const int SIZE = 8;\n    int node_keys[8] = {5, 3, 2, 4, 7, 6, 8, 1};\n    int i;\n    tree *root = NULL;\n\n    root = insert_node(root, node_keys[0]);\n\n    for (i = 1; i < SIZE; i++)\n    {\n        insert_node(root, node_keys[i]);\n    }\n\n    printf("Print tree by in-order (depth first) traversal order:\\n");\n    print_tree(root);\n    printf("\\n");\n\n    tree *find = search(root, 7);\n    printf("\\nSearch: looking for \'7\' and got \'%d\'\\n", find->key);\n\n    printf("\\nPrinting tree level by level (breadth first traversal):\\n");\n    print_tree_levels(root);\n\n    return 0;\n}\n',i='// write a code that build a little 1-2-3 binary search tree\n#include <iostream>\nusing namespace std;\n\nstruct node\n{\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node *new_node(int data)\n{\n    struct node *node = new (struct node);\n    node->data = data;\n    node->left = nullptr;\n    node->right = nullptr;\n\n    return node;\n}\n\nstruct node *insert(struct node *node, int data)\n{\n    // if the tree is empty, return a new and single node\n    if (node == NULL)\n    {\n        return (new_node(data));\n    }\n    else\n    {\n        if (data < node->data)\n        {\n            node->left = insert(node->left, data);\n        }\n        else\n        {\n            node->right = insert(node->right, data);\n        }\n\n        return node;\n    }\n}\n\nvoid print_tree(struct node *node)\n{\n    if (node == nullptr)\n    {\n        return;\n    }\n    else if (node->left == nullptr && node->right == nullptr)\n    {\n        cout << node->data;\n        return;\n    }\n    else\n    {\n        cout << node->data;\n\n        if (node->left != nullptr && node->right != nullptr)\n        {\n            cout << "[";\n            print_tree(node->left);\n            cout << ",";\n            print_tree(node->right);\n            cout << "]";\n        }\n        else if (node->right == nullptr)\n        {\n            cout << "[";\n            print_tree(node->left);\n            cout << "]";\n        }\n        else\n        {\n            cout << "[";\n            print_tree(node->right);\n            cout << "]";\n        }\n    }\n}\n\nint size(struct node *node)\n{\n    if (node == nullptr)\n    {\n        return 0;\n    }\n    else\n    {\n        return (size(node->left) + size(node->right) + 1);\n    }\n}\n\nint max_depth(struct node *node)\n{\n    if (node == nullptr)\n    {\n        return 0;\n    }\n    else\n    {\n        int left_depth = max_depth(node->left);\n        int right_depth = max_depth(node->right);\n\n        if (left_depth > right_depth)\n        {\n            return (left_depth + 1);\n        }\n        else\n        {\n            return (right_depth + 1);\n        }\n    }\n}\n\nint main()\n{\n    struct node *root = NULL;\n    root = new_node(2);\n    root = insert(root, 1);\n    root = insert(root, 3);\n\n    print_tree(root);\n    cout << endl;\n    cout << "size = " << size(root) << endl;\n    cout << "max_depth = " << max_depth(root) << endl;\n\n    struct node *test;\n    test = new_node(5);\n    test = insert(test, 6);\n    test = insert(test, 3);\n    test = insert(test, 1);\n    test = insert(test, 2);\n    test = insert(test, 7);\n    test = insert(test, 9);\n    test = insert(test, 5);\n    test = insert(test, 0);\n    print_tree(test);\n\n    cout << endl;\n    cout << "size = " << size(test) << endl;\n    cout << "max_depth = " << max_depth(test) << endl;\n\n    return 0;\n}\n',l={title:"Binary trees"},c=void 0,h={unversionedId:"data-structure/binary-trees",id:"data-structure/binary-trees",title:"Binary trees",description:"Tree is a dynamic data structure composed of multi-levels of linked lists. A",source:"@site/docs/data-structure/binary-trees.mdx",sourceDirName:"data-structure",slug:"/data-structure/binary-trees",permalink:"/c-cpp/data-structure/binary-trees",draft:!1,editUrl:"https://github.com/pranabdas/c-cpp/blob/main/docs/data-structure/binary-trees.mdx",tags:[],version:"current",frontMatter:{title:"Binary trees"},sidebar:"docs",previous:{title:"Linked list",permalink:"/c-cpp/data-structure/linked-list"},next:{title:"Binary heaps",permalink:"/c-cpp/data-structure/heaps"}},d={},u=[{value:"Binary Search Tree",id:"binary-search-tree",level:3},{value:"Traversal algorithms",id:"traversal-algorithms",level:3},{value:"Depth First Search",id:"depth-first-search",level:3},{value:"Balanced binary tree (AVL tree)",id:"balanced-binary-tree-avl-tree",level:3},{value:"Resources",id:"resources",level:3}],N={toc:u},k="wrapper";function f(e){let{components:t,...l}=e;return(0,r.kt)(k,(0,n.Z)({},N,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Tree is a dynamic data structure composed of multi-levels of linked lists. A\ntree is defined as a node which consists of a value together with a list of\nreferences (pointers) to other such nodes. The top most node is called ",(0,r.kt)("strong",{parentName:"p"},"root"),"\nof the tree. Nodes are called parent if they points to other nodes, which are\ncalled ",(0,r.kt)("strong",{parentName:"p"},"children"),"."),(0,r.kt)("p",null,"The simplest type of tree is a binary tree. A node in binary tree can have a\nmaximum of two references (called children), denoted by ",(0,r.kt)("strong",{parentName:"p"},"left")," and ",(0,r.kt)("strong",{parentName:"p"},"right"),".\nNodes without children is called leaf. The parent, grand parent, ... of a node\nis called ancestor nodes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Depth:")," the depth of a node is the number of its ancestors. It is also the\nnumber of edges from that particular node to the root node. Root node has depth\n0."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Height:")," height of a node is the number of edges in the longest downward\npath. It is also the maximum depth of subtree rooted on that particular node.\nAll leafs have height 0."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Size:")," of a node is the number of nodes (including the node itself) in the\nsubtree rooted on that node."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Set vs. Sequence:")," when we work on a set interface, we look for items in a\ntree using the key. On the other hand, in case of a sequence implementation, we\nlook for items by its index. When looking for items by index, size of a subtree\nis important. Below is a pseudo code to find item by index:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"tree *search(tree *node, i) {\n    size_left = size(node->left)\n    if (i < size_left) {\n        search(node->left, i)\n    } else if (i == size_left) {\n        return node;\n    } else { // i > size_left\n        search(node->right, i - size_left - 1)\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Subtree augmentation:")," we can maintain certain properties of a subtree as a\ndata member of a node, e.g, size of a subtree, minimum, maximum. Then we can\ncalculate size of any tree/subtree in constant time. Whenever, we insert or\ndelete new item to the tree, we need to update those node properties as well. We\nmust be able to efficiently (time complexity better than or same as\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"h"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(h)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),") maintain such properties during tree modification. There are\nproperties that we can not maintain efficiently such as index of a node; that\nwould be ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," operation."),(0,r.kt)("h3",{id:"binary-search-tree"},"Binary Search Tree"),(0,r.kt)("p",null,"A Binary Search Tree (BST) is a binary tree with following properties:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"All node keys are distinct"),(0,r.kt)("li",{parentName:"ol"},"The left subtree of a node contains only keys less than its key"),(0,r.kt)("li",{parentName:"ol"},"Right subtree contains only keys greater than current node key"),(0,r.kt)("li",{parentName:"ol"},"Both left and right subtrees are also binary search tree.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("mermaid",{value:'graph TB;\n    A((10)) --\x3e B((5))\n    A --\x3e C((12))\n    B --\x3e D((2))\n    B --\x3e E((7))\n    E --\x3e F((6))\n    E --\x3e G((9))\n    C --\x3e H(("X"))\n    C --\x3e I((14))\n    I --\x3e K((13))\n    I --\x3e L(("X"))'}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"X")," here represents ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," pointer."),(0,r.kt)("p",null,"Since BST provides an ordering among the node keys, operations such search,\nfind minimum, maximum becomes easier. The search depth of BST depends on the\nshape of the tree. If a tree is balanced the complexity is\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"h"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(h)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),". In the worst case, when the tree is highly unbalanced (a\nsingly linked list) the time complexity of search is ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,r.kt)(s.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(m.Z,{value:"C",mdxType:"TabItem"},(0,r.kt)(p.Z,{language:"c",title:"src/c/data-structure/binary-tree.c",showLineNumbers:!0,mdxType:"CodeBlock"},o)),(0,r.kt)(m.Z,{value:"C++",mdxType:"TabItem"},(0,r.kt)(p.Z,{language:"cpp",title:"src/cpp/data-structure/binary-tree.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},i))),(0,r.kt)("h3",{id:"traversal-algorithms"},"Traversal algorithms"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pre-order traversal:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->left")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->right")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"In-order traversal:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"node->left")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->right"),". In the above tree\ndiagram, in-order traversal would be: 2, 5, 6, 7, 9, 10, 12, 13, 14."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Post-order traversal:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"node->left")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->right")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node"),"."),(0,r.kt)("p",null,"Note that there could be more than one (unique) tree representation for the same\ntraversal order."),(0,r.kt)("h3",{id:"depth-first-search"},"Depth First Search"),(0,r.kt)("p",null,"Above traversal algorithms are depth first algorithm, which use a stack for\nback-tracking. They can be implemented by recursion as shown in the above code\nexample."),(0,r.kt)("h3",{id:"balanced-binary-tree-avl-tree"},"Balanced binary tree (AVL tree)"),(0,r.kt)("p",null,"How do we ensure ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"h"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"log"),(0,r.kt)("mo",{parentName:"mrow"},"\u2061"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(h) = \\mathcal{O}(\\log n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mop"},"lo",(0,r.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"h")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"h")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"h")))))," is the height\nof a tree and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," is the total number of items in the tree? We know that in case\nof a balanced binary tree ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"h"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"log"),(0,r.kt)("mo",{parentName:"mrow"},"\u2061"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(h) = \\mathcal{O}(\\log n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mop"},"lo",(0,r.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),". There are\nseveral category of balanced binary trees."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Rotation:")," We must ensure the traversal order after rotation. We must ensure\nthat traversal order is unchanged after rotation. In case of AVL tree, we\nmaintain the height balance. Skew of a node is defined as\n",(0,r.kt)("inlineCode",{parentName:"p"},"height(node->right) - height(node->left)"),". We like to maintain the skew of\nany node to be either 0, or 1 or -1. If we can maintain height balance,\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"h"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"log"),(0,r.kt)("mo",{parentName:"mrow"},"\u2061"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(h) = \\mathcal{O}(\\log n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mop"},"lo",(0,r.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", indeed."),(0,r.kt)("picture",null,(0,r.kt)("source",{type:"image/webp",srcSet:a(4118).Z}),(0,r.kt)("img",{src:a(6955).Z,alt:"tree-rotation"})),(0,r.kt)("p",null,"After rotation we need to update the subtree properties of A, B, and all their\nancestors, which could be done in ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"log"),(0,r.kt)("mo",{parentName:"mrow"},"\u2061"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(\\log n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mop"},"lo",(0,r.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," time."),(0,r.kt)("h3",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=76dhtgZt38A&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=9"},"MIT OCW Binary Trees Lecture 1")," (",(0,r.kt)("a",{target:"_blank",href:a(8817).Z},"related notes"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=U1JYwHcFfso&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=11"},"MIT OCW Binary Trees Lecture 2")," (",(0,r.kt)("a",{target:"_blank",href:a(4035).Z},"related notes"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:a(2806).Z},"Representing general tree as binary tree"))))}f.isMDXComponent=!0},8817:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/files/MIT6_006S20_r06_binary_tree-f0e17a7a81774744aed4f0421f08c494.pdf"},4035:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/files/MIT6_006S20_r07_balanced_binary_tree-3e52d54bd5e80862f01464b955429a0d.pdf"},2806:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/files/binary_tree_from_general_tree_gavrilova-c46a4feb3ffc4afc8ae1049eee6f553e.pdf"},6955:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tree-rotation-e3801cfa36f139224a313f8a45febe7f.png"},4118:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tree-rotation-935123fbf729177776745fe9436d11fd.webp"}}]);