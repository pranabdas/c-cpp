"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[257],{5162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(7294),r=t(6010);const s="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,o),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>u});var a=t(7462),r=t(7294),s=t(6010),o=t(2389),i=t(7392),l=t(7094),d=t(2466);const p="tabList__CuJ",m="tabItem_LNqP";function c(e){const{lazy:n,block:t,defaultValue:o,values:c,groupId:u,className:h}=e,k=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=c??k.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),N=(0,i.l)(f,((e,n)=>e.value===n.value));if(N.length>0)throw new Error(`Docusaurus error: Duplicate values "${N.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===o?o:o??k.find((e=>e.props.default))?.props.value??k[0].props.value;if(null!==y&&!f.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:g,setTabGroupChoices:b}=(0,l.U)(),[v,w]=(0,r.useState)(y),_=[],{blockElementScrollPositionUntilNextRender:x}=(0,d.o5)();if(null!=u){const e=g[u];null!=e&&e!==v&&f.some((n=>n.value===e))&&w(e)}const T=e=>{const n=e.currentTarget,t=_.indexOf(n),a=f[t].value;a!==v&&(x(n),w(a),null!=u&&b(u,String(a)))},L=e=>{let n=null;switch(e.key){case"Enter":T(e);break;case"ArrowRight":{const t=_.indexOf(e.currentTarget)+1;n=_[t]??_[0];break}case"ArrowLeft":{const t=_.indexOf(e.currentTarget)-1;n=_[t]??_[_.length-1];break}}n?.focus()};return r.createElement("div",{className:(0,s.Z)("tabs-container",p)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},h)},f.map((e=>{let{value:n,label:t,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:v===n?0:-1,"aria-selected":v===n,key:n,ref:e=>_.push(e),onKeyDown:L,onClick:T},o,{className:(0,s.Z)("tabs__item",m,o?.className,{"tabs__item--active":v===n})}),t??n)}))),n?(0,r.cloneElement)(k.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},k.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==v})))))}function u(e){const n=(0,o.Z)();return r.createElement(c,(0,a.Z)({key:String(n)},e))}},120:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var a=t(7462),r=(t(7294),t(3905)),s=t(5488),o=t(5162),i=t(6823);const l={title:"Trees"},d=void 0,p={unversionedId:"data-structure/binary-trees",id:"data-structure/binary-trees",title:"Trees",description:"Tree is a dynamic data structure composed of multi-levels of linked lists. A",source:"@site/docs/data-structure/binary-trees.mdx",sourceDirName:"data-structure",slug:"/data-structure/binary-trees",permalink:"/c-cpp/data-structure/binary-trees",draft:!1,editUrl:"https://github.com/pranabdas/c-cpp/blob/main/docs/data-structure/binary-trees.mdx",tags:[],version:"current",frontMatter:{title:"Trees"},sidebar:"docs",previous:{title:"Linked list",permalink:"/c-cpp/data-structure/linked-list"},next:{title:"File IO",permalink:"/c-cpp/category/file-io"}},m={},c=[{value:"Binary Tree",id:"binary-tree",level:2},{value:"Binary Search Tree",id:"binary-search-tree",level:3},{value:"Traversal algorithms",id:"traversal-algorithms",level:3},{value:"Depth First Search",id:"depth-first-search",level:3},{value:"Resources",id:"resources",level:3}],u={toc:c};function h(e){let{components:n,...l}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Tree is a dynamic data structure composed of multi-levels of linked lists. A\ntree is defined as a node which consists of a value together with a list of\nreferences (pointers) to other such nodes. The top most node is called ",(0,r.kt)("strong",{parentName:"p"},"root"),"\nof the tree. Nodes are called parent if they points to other nodes, which are\ncalled ",(0,r.kt)("strong",{parentName:"p"},"children"),"."),(0,r.kt)("h2",{id:"binary-tree"},"Binary Tree"),(0,r.kt)("p",null,"The simplest type of tree is a binary tree. A node in binary tree can have a\nmaximum of two references (called children), denoted by ",(0,r.kt)("strong",{parentName:"p"},"left")," and ",(0,r.kt)("strong",{parentName:"p"},"right"),"."),(0,r.kt)("h3",{id:"binary-search-tree"},"Binary Search Tree"),(0,r.kt)("p",null,"A Binary Search Tree (BST) is a binary tree with following properties:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"All node keys are distinct"),(0,r.kt)("li",{parentName:"ol"},"The left subtree of a node contains only keys less than its key"),(0,r.kt)("li",{parentName:"ol"},"Right subtree contains only keys greater than current node key"),(0,r.kt)("li",{parentName:"ol"},"Both left and right subtrees are also binary search tree.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("mermaid",{value:'graph TB;\n    A((10)) --\x3e B((5))\n    A --\x3e C((12))\n    B --\x3e D((2))\n    B --\x3e E((7))\n    E --\x3e F((6))\n    E --\x3e G((9))\n    C --\x3e H(("X"))\n    C --\x3e I((14))\n    I --\x3e K((13))\n    I --\x3e L(("X"))'}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"X")," here represents ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," pointer."),(0,r.kt)("p",null,"Since BST provides an ordering amomng the node keys, operations such search,\nfind minimum, maximum becomes easier. The search depth of BST depends on the\nshape of the tree. If a tree is balanced the complexity is\n",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"log"),(0,r.kt)("mo",{parentName:"mrow"},"\u2061"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(\\log n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mop"},"lo",(0,r.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),". In the worst case, when the tree is highly unbalanced\n(a sigly linked list) the time complexity of search is ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,r.kt)(s.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"C",mdxType:"TabItem"},(0,r.kt)(i.Z,{language:"c",title:"src/c/data-structure/binary-tree.c",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\ntypedef struct tree\n{\n    int key;\n    struct tree *left, *right;\n} tree;\n\ntree *create_tree(int key)\n{\n    tree *node = (tree *)malloc(sizeof(tree));\n    assert(node);\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n\n    return node;\n}\n\ntree *insert_node(tree *node, int key)\n{\n    if (node == NULL)\n    {\n        return (create_tree(key));\n    }\n\n    if (key < node->key)\n    {\n        node->left = insert_node(node->left, key);\n    }\n    else if (key > node->key)\n    {\n        node->right = insert_node(node->right, key);\n    }\n\n    return node;\n}\n\nvoid print_tree(tree *node)\n{\n    if (node == NULL)\n    {\n        return;\n    }\n    else if (node->left == NULL && node->right == NULL)\n    {\n        printf("%d", node->key);\n        return;\n    }\n    else\n    {\n        printf("%d", node->key);\n\n        if (node->left != NULL && node->right != NULL)\n        {\n            printf("[");\n            print_tree(node->left);\n            printf(", ");\n            print_tree(node->right);\n            printf("]");\n        }\n        else if (node->right == NULL)\n        {\n            printf("[");\n            print_tree(node->left);\n            printf("]");\n        }\n        else\n        {\n            printf("[");\n            print_tree(node->right);\n            printf("]");\n        }\n    }\n}\n\n// depth first search\ntree *search(tree *node, int key)\n{\n    if (node == NULL || node->key == key)\n    {\n        return node;\n    }\n\n    if (key < node->key)\n    {\n        return search(node->left, key);\n    }\n    else\n    {\n        return search(node->right, key);\n    }\n}\n\nint main()\n{\n    const int SIZE = 7;\n    int node_keys[7] = {5, 3, 1, 4, 7, 6, 8};\n    int i;\n    tree *root = NULL;\n\n    root = insert_node(root, node_keys[0]);\n\n    for (i = 1; i < SIZE; i++)\n    {\n        insert_node(root, node_keys[i]);\n    }\n\n    print_tree(root);\n    printf("\\n");\n\n    tree *find = search(root, 7);\n    printf("Looking for 7 and got %d\\n", find->key);\n\n    return 0;\n}\n')),(0,r.kt)(o.Z,{value:"C++",mdxType:"TabItem"},(0,r.kt)(i.Z,{language:"cpp",title:"src/cpp/data-structure/binary-tree.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'// write a code that build a little 1-2-3 binary search tree\n#include <iostream>\nusing namespace std;\n\nstruct node\n{\n    int data;\n    struct node *left;\n    struct node *right;\n};\n\nstruct node *new_node(int data)\n{\n    struct node *node = new (struct node);\n    node->data = data;\n    node->left = nullptr;\n    node->right = nullptr;\n\n    return node;\n}\n\nstruct node *insert(struct node *node, int data)\n{\n    // if the tree is empty, return a new and single node\n    if (node == NULL)\n    {\n        return (new_node(data));\n    }\n    else\n    {\n        if (data < node->data)\n        {\n            node->left = insert(node->left, data);\n        }\n        else\n        {\n            node->right = insert(node->right, data);\n        }\n\n        return node;\n    }\n}\n\nvoid print_tree(struct node *node)\n{\n    if (node == nullptr)\n    {\n        return;\n    }\n    else if (node->left == nullptr && node->right == nullptr)\n    {\n        cout << node->data;\n        return;\n    }\n    else\n    {\n        cout << node->data;\n\n        if (node->left != nullptr && node->right != nullptr)\n        {\n            cout << "[";\n            print_tree(node->left);\n            cout << ",";\n            print_tree(node->right);\n            cout << "]";\n        }\n        else if (node->right == nullptr)\n        {\n            cout << "[";\n            print_tree(node->left);\n            cout << "]";\n        }\n        else\n        {\n            cout << "[";\n            print_tree(node->right);\n            cout << "]";\n        }\n    }\n}\n\nint size(struct node *node)\n{\n    if (node == nullptr)\n    {\n        return 0;\n    }\n    else\n    {\n        return (size(node->left) + size(node->right) + 1);\n    }\n}\n\nint max_depth(struct node *node)\n{\n    if (node == nullptr)\n    {\n        return 0;\n    }\n    else\n    {\n        int left_depth = max_depth(node->left);\n        int right_depth = max_depth(node->right);\n\n        if (left_depth > right_depth)\n        {\n            return (left_depth + 1);\n        }\n        else\n        {\n            return (right_depth + 1);\n        }\n    }\n}\n\nint main()\n{\n    struct node *root = NULL;\n    root = new_node(2);\n    root = insert(root, 1);\n    root = insert(root, 3);\n\n    print_tree(root);\n    cout << endl;\n    cout << "size = " << size(root) << endl;\n    cout << "max_depth = " << max_depth(root) << endl;\n\n    struct node *test;\n    test = new_node(5);\n    test = insert(test, 6);\n    test = insert(test, 3);\n    test = insert(test, 1);\n    test = insert(test, 2);\n    test = insert(test, 7);\n    test = insert(test, 9);\n    test = insert(test, 5);\n    test = insert(test, 0);\n    print_tree(test);\n\n    cout << endl;\n    cout << "size = " << size(test) << endl;\n    cout << "max_depth = " << max_depth(test) << endl;\n\n    return 0;\n}\n'))),(0,r.kt)("h3",{id:"traversal-algorithms"},"Traversal algorithms"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pre-order traversal:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->left")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->right"),"\n",(0,r.kt)("strong",{parentName:"p"},"In-order traversal:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"node->left")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->right"),"\n",(0,r.kt)("strong",{parentName:"p"},"Post-order traversal:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"node->left")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node->right")," \u2192 ",(0,r.kt)("inlineCode",{parentName:"p"},"node")),(0,r.kt)("h3",{id:"depth-first-search"},"Depth First Search"),(0,r.kt)("p",null,"Above traversal algorithms are depth first algorithm, which use a stack for\nback-tracking. They can be implemented by recusion as shown in the above code\nexample."),(0,r.kt)("h3",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=76dhtgZt38A&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=9"},"MIT OCW Binary Trees Lecture 1")," (",(0,r.kt)("a",{target:"_blank",href:t(6480).Z},"related notes"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=U1JYwHcFfso&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=11"},"MIT OCW Binary Trees Lecture 2")," (",(0,r.kt)("a",{target:"_blank",href:t(2184).Z},"related notes"),")")))}h.isMDXComponent=!0},6480:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/MIT6_006S20_r06_binary_trees-f0e17a7a81774744aed4f0421f08c494.pdf"},2184:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/MIT6_006S20_r07_balanced_binary_trees-3e52d54bd5e80862f01464b955429a0d.pdf"}}]);