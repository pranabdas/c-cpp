"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[6596],{4407:(a,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>p,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var n=t(7462),s=(t(7294),t(3905)),m=t(814);const r={title:"Sorting algorithms",sidebar_label:"Sorting"},p=void 0,i={unversionedId:"algorithms/sorting",id:"algorithms/sorting",title:"Sorting algorithms",description:"Computers spend a lot of time sorting while processing data. Once sorting is",source:"@site/docs/algorithms/sorting.mdx",sourceDirName:"algorithms",slug:"/algorithms/sorting",permalink:"/c-cpp/algorithms/sorting",draft:!1,editUrl:"https://github.com/pranabdas/c-cpp/blob/main/docs/algorithms/sorting.mdx",tags:[],version:"current",frontMatter:{title:"Sorting algorithms",sidebar_label:"Sorting"},sidebar:"docs",previous:{title:"Complexity analysis",permalink:"/c-cpp/algorithms/big-o"},next:{title:"Data structure",permalink:"/c-cpp/category/data-structure"}},l={},o=[{value:"Permutation sort",id:"permutation-sort",level:3},{value:"Selection sort",id:"selection-sort",level:3},{value:"Insertion sort",id:"insertion-sort",level:3},{value:"Merge sort",id:"merge-sort",level:3},{value:"Linear sort",id:"linear-sort",level:3},{value:"Resources",id:"resources",level:3}],N={toc:o};function c(a){let{components:e,...r}=a;return(0,s.kt)("wrapper",(0,n.Z)({},N,r,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Computers spend a lot of time sorting while processing data. Once sorting is\ndone, many other problems becomes very easy. It is also one of the most studied\nproblem in computer science. Many of the interesting ideas such as\ndive-and-conquer, randomized algorithms, lower bounds etc. can be found in the\ncontext of sorting. Here we will look into some of the sorting algorithms and\nhow they scales with increasing problem size."),(0,s.kt)("h3",{id:"permutation-sort"},"Permutation sort"),(0,s.kt)("p",null,"Given an array, we create all possible permutations of the array items, then\ncheck if the one of those permutations are sorted. This algorithm is extremely\ninefficient, there are ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"!")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n!")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"!")))))," possible permutations of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"n")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," items. Even for a\nrelatively small number of input size 20, ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mn",{parentName:"mrow"},"20"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"!"),(0,s.kt)("mo",{parentName:"mrow"},"\u2248"),(0,s.kt)("mn",{parentName:"mrow"},"2"),(0,s.kt)("mo",{parentName:"mrow"},"\xd7"),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mn",{parentName:"msup"},"0"),(0,s.kt)("mn",{parentName:"msup"},"18"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(20)! \\approx 2 \\times 10^{18}")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},"20"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")!"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2248"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"2"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"\xd7"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord"},"0"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"18"))))))))))))),". For\neach step, we also need about ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," checks to find out if one of the\npermutations is sorted."),(0,s.kt)("h3",{id:"selection-sort"},"Selection sort"),(0,s.kt)("p",null,"Here is how the selection sort works: say we are given the following array to\nsort: ","[5, 8, 2, 3, 7, 9]"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Step 1:")," find the biggest element in first (n - 1) element and swap it with\nthe last element if it is bigger than the last element else do nothing"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Step 2:")," find biggest element in first (n - 2) element, and swap it with\n(n-1)th element if it is bigger"),(0,s.kt)("p",null,"Below is an implementation in C++."),(0,s.kt)(m.Z,{language:"cpp",title:"src/cpp/misc/selection_sort.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <iostream>\n#include <tuple>\nusing namespace std;\n\ntuple<int, int> find_biggest(int arr[], int size)\n{\n    int biggest = arr[0];\n    int id = 0;\n\n    for (int i = 0; i < size; i++)\n    {\n        if (arr[i] > biggest)\n        {\n            biggest = arr[i];\n            id = i;\n        }\n    }\n\n    return make_tuple(biggest, id);\n}\n\nint main()\n{\n    int arr[] = {5, 8, 2, 3, 7, 4};\n    const int SIZE = 6;\n\n    for (int i = 1; i < SIZE; i++)\n    {\n        int biggest, id;\n        tie(biggest, id) = find_biggest(arr, SIZE - i);\n\n        if (biggest > arr[SIZE - i])\n        {\n            int tmp = arr[SIZE - i];\n            arr[SIZE - i] = biggest;\n            arr[id] = tmp;\n        }\n    }\n\n    for (int i = 0; i < SIZE; i++)\n    {\n        cout << arr[i] << "  ";\n    }\n    cout << endl;\n\n    return 0;\n}\n'),(0,s.kt)("h3",{id:"insertion-sort"},"Insertion sort"),(0,s.kt)(m.Z,{language:"cpp",title:"src/cpp/misc/insertion_sort.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int arr[] = {5, 8, 2, 3, 7, 4};\n    const int SIZE = 6;\n\n    for (int i = 1; i < SIZE; i++)\n    {\n        int j = i;\n        while (j > 0 && arr[j] < arr[j - 1])\n        {\n            int tmp = arr[j];\n            arr[j] = arr[j - 1];\n            arr[j - 1] = tmp;\n            j--;\n        }\n    }\n\n    for (int i = 0; i < SIZE; i++)\n    {\n        cout << arr[i];\n\n        if (i != SIZE - 1)\n        {\n            cout << ", ";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}\n'),(0,s.kt)("p",null,"Both selection sort and insertion sort has time complexity ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"n"),(0,s.kt)("mn",{parentName:"msup"},"2")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n^2)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,s.kt)("h3",{id:"merge-sort"},"Merge sort"),(0,s.kt)(m.Z,{language:"cpp",title:"src/cpp/misc/merge_sort.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <iostream>\nusing namespace std;\n\nvoid print_array(int arr[], const int SIZE)\n{\n    for (int i = 0; i < SIZE; i++)\n    {\n        cout << arr[i];\n        if (i < SIZE - 1)\n        {\n            cout << ", ";\n        }\n    }\n    cout << endl;\n}\n\nvoid merge(int arr[], const int start, const int center, const int end)\n{\n    // temporary arrays\n    auto *left_array = new int[center - start];\n    auto *right_array = new int[end - center];\n\n    // copy data to temp arrays\n    for (auto i = 0; i < center - start; i++)\n    {\n        left_array[i] = arr[start + i];\n    }\n\n    for (auto i = 0; i < end - center; i++)\n    {\n        right_array[i] = arr[center + i];\n    }\n\n    // merge\n    int i = 0;\n    int j = 0;\n    int left = start;\n    while (left < end)\n    {\n        if ((j >= end - center) || ((i < center - start) && (left_array[i] < right_array[j])))\n        {\n            arr[left] = left_array[i];\n            i++;\n        }\n        else\n        {\n            arr[left] = right_array[j];\n            j++;\n        }\n        left++;\n    }\n\n    delete[] left_array;\n    delete[] right_array;\n}\n\nvoid merge_sort(int arr[], int start, int end)\n{\n    if (end - start > 1)\n    {\n        auto center = (start + end + 1) / 2;\n        merge_sort(arr, start, center);\n        merge_sort(arr, center, end);\n        merge(arr, start, center, end);\n    }\n}\n\nint main()\n{\n    int arr[] = {5, 8, 2, 3, 7, 4};\n    const int SIZE = 6;\n\n    merge_sort(arr, 0, SIZE);\n    print_array(arr, 6);\n\n    return 0;\n}\n'),(0,s.kt)("p",null,"Merge sort has time complexity ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mi",{parentName:"mrow"},"log"),(0,s.kt)("mo",{parentName:"mrow"},"\u2061"),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n \\log n)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mop"},"lo",(0,s.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),". Note that for any\ncomparison model, there are ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"!")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n!")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"!")))))," possible outcomes for a problem size ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"n")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),".\nMinimum height of such as descision tree would be ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"log"),(0,s.kt)("mo",{parentName:"mrow"},"\u2061"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"!"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.kt)("mo",{parentName:"mrow"},"\u2248"),(0,s.kt)("mi",{parentName:"mrow"},"n"),(0,s.kt)("mi",{parentName:"mrow"},"log"),(0,s.kt)("mo",{parentName:"mrow"},"\u2061"),(0,s.kt)("mi",{parentName:"mrow"},"n")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\log(n!) \\approx n \\log n")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mop"},"lo",(0,s.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"!)"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2248"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mop"},"lo",(0,s.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),".\nTherefore, merge sort is best possible (or close to best possible) solution for\nany sorting algorithm based on comparison model. Can we do better?"),(0,s.kt)("h3",{id:"linear-sort"},"Linear sort"),(0,s.kt)("p",null,"It takes constant amount of time to access a memory location (RAM) by its\naddress. If we are able to build a direct access array (DAA), we can get its\nelements by its index. We can build key value pairs, where keys are index of an\nDAA. If we have to search through the array, we can get an item in constant\ntime. Say we have ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"n")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," items and the key space is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"u")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u"))))),". If ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"n")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"u")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"u")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"u")))))," are of the\nsame order, then such an algorithm would be efficient. Example: say we have\nstudent IDs (keys) based on their ranking."),(0,s.kt)("p",null,"What if key space is of the order of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"n"),(0,s.kt)("mn",{parentName:"msup"},"2"))),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n^2")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))))),"? In that case, we can break down each\nkey in a tuple of (a, b), where ",(0,s.kt)("inlineCode",{parentName:"p"},"a = u / n")," (integer division), and ",(0,s.kt)("inlineCode",{parentName:"p"},"b = u % n"),"\n(remainder of modulo division). Example: say we have a list of 5 numbers:\n{12, 17, 3, 22, 24}, we can transform them into {(2, 2), (3, 2), (0, 3), (4,2),\n(4, 4)}. Now, if we need to sort them (we can call tuple sort), we need to sort\nfirst based on the least significant tuple digit (here second digit), and we\nobtain: {(2, 2), (3, 2), (4, 2), (0, 3), (4, 4)}. Finally, we sort by the most\nsignificant tuple digit: {(0, 3), (2, 2), (3, 2), (4, 2), (4, 4)}."),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"Note that we need a stable sorting algorithm to sort above tuple, i.e., it\nmaintains the order of numbers in the original input list. If the input tuple\nwas {(2, 3), (2, 1)} after sorting based on most significant tuple digit (i.e.,\nfirst digit), it should return {(2, 3), (2, 1)}.")),(0,s.kt)("h3",{id:"resources"},"Resources"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=oS9aPzUNG-s&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=4"},"MIT OCW Lecture Video")," (",(0,s.kt)("a",{target:"_blank",href:t(6017).Z},"related notes"),")"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=yndgIDO0zQQ&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=7"},"Linear Sorting lecture video from MIT OCW")," (",(0,s.kt)("a",{target:"_blank",href:t(1047).Z},"related notes"),")")))}c.isMDXComponent=!0},6017:(a,e,t)=>{t.d(e,{Z:()=>n});const n=t.p+"assets/files/MIT6_006S20_r03_sorting-0d388861e858099d2d60b052dfc1468a.pdf"},1047:(a,e,t)=>{t.d(e,{Z:()=>n});const n=t.p+"assets/files/MIT6_006S20_r05_linear_sorting-9bc94dfbbe64710e69585629157e6914.pdf"}}]);