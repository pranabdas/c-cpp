"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[3249],{1331:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>m,contentTitle:()=>p,default:()=>h,frontMatter:()=>d,metadata:()=>a,toc:()=>f});const a=JSON.parse('{"id":"arrays-pointers/array-basics","title":"Array basics","description":"","source":"@site/docs/arrays-pointers/array-basics.mdx","sourceDirName":"arrays-pointers","slug":"/arrays-pointers/array-basics","permalink":"/c-cpp/arrays-pointers/array-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/pranabdas/c-cpp/blob/main/docs/arrays-pointers/array-basics.mdx","tags":[],"version":"current","frontMatter":{"title":"Array basics"},"sidebar":"docs","previous":{"title":"Array and Pointer","permalink":"/c-cpp/category/array-and-pointer"},"next":{"title":"Pointer basics","permalink":"/c-cpp/arrays-pointers/pointer-basics"}}');var t=e(4848),i=e(8453),s=e(1470),o=e(9365),l=e(1432);const u='#include <stdio.h>\n\nint main()\n{\n    const int SIZE = 5;\n\n    // int array1[SIZE] = {0}; // if the array size is not knowns compile time,\n                            // use heap dynamic memory\n    // int array2[SIZE] = {1, 2, 3, 4, 5};\n    // some compiler might complain here, use 5 instead of SIZE\n    // fails in gcc, however works in apple clang\n    int array1[5] = {0};\n    int array2[5] = {1, 2, 3, 4, 5};\n    int array3[] = {1, 2, 3, 4, 5};\n\n    char str1[] = "hello";\n\n    int i;\n    double sum2 = 0, sum3 = 0;\n    double *ptr_sum2 = &sum2;\n\n    for (i = 0; i < SIZE; i++)\n    {\n        sum2 += array2[i];\n        sum3 += array3[i];\n    }\n\n    printf("Sum2 = %f\\n", sum2);\n    printf("Sum3 = %f\\n", sum3);\n\n    printf("Pointer sum2: %p\\n", ptr_sum2);\n    printf("Sum2 = %f\\n", *ptr_sum2);\n\n    printf("array2 position: %p\\n", array2);\n\n    return 0;\n}\n',c='#include <iostream>\nusing namespace std;\n\nvoid print_2d_array(float *, int, int);\n\nint main()\n{\n    int arr[] = {2, 4, 8, 15};\n    // arr[4] = {1, 2};\n    // above assignment sets: arr[0] = 1, arr[1] = 2, arr[2] = 0, arr[3] = 0\n    // aggregation initialization:\n    // note that if we do not provide any value via curly braces, the array\n    // remains uninitialized. To make sure array is initialized to zeros:\n    // arr[4] = {}\n\n    for (int i : arr)\n    {\n        cout << i << endl;\n    }\n\n    const int SIZE = 10; // `const` is necessary here\n    double data[SIZE];\n    // if the size of array is not known compile time, use heap dynamic array\n\n    cout << "Size of data = " << sizeof(data) << " bytes\\n";\n    cout << "Length of data array: " << sizeof(data) / sizeof(data[0]) << endl;\n    // the above prints the size of the entire array\n\n    // multi-dimensional array:\n    float arr2d[3][4] = {0.0}; // this initializes all elements to with 0.0\n    cout << "\\narr2d:\\n";\n    print_2d_array(&arr2d[0][0], 3, 4);\n\n    float arr2d2[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    cout << "\\narr2d2:\\n";\n    print_2d_array(&arr2d2[0][0], 3, 4);\n\n    float arr2d3[3][4] = {{1.1, 2.2, 3.3, 4.4},\n                          {5.5, 6.6, 7.7, 8.8},\n                          {9.9, 10., 11., 12.}};\n    cout << "\\narr2d3:\\n";\n    print_2d_array(&arr2d3[0][0], 3, 4);\n\n    float arr2d4[][4] = {{1.1, 2.2, 3.3, 4.4},\n                          {5.5, 6.6, 7.7, 8.8},\n                          {9.9, 10., 11., 12.}};\n    cout << "\\narr2d4:\\n";\n    print_2d_array(&arr2d4[0][0], 3, 4);\n\n    float arr2d5[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    cout << "\\narr2d5:\\n";\n    print_2d_array(&arr2d5[0][0], 3, 4);\n\n    float arr2d6[3][4] = {0.3}; // sets first element to 0.3, rest to 0.0\n    cout << "\\narr2d6:\\n";\n    print_2d_array(&arr2d6[0][0], 3, 4);\n\n    return 0;\n}\n\nvoid print_2d_array(float *arr, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            // array elements are continuously stored row by row in C++\n            cout << *(arr + (n * i) + j) << "\\t";\n            //      |   --- pointer to the first element, do the pointer\n            //      |       arithmetic to get the next elements\n            //      dereference the value\n        }\n        cout << endl;\n    }\n}\n',d={title:"Array basics"},p=void 0,m={},f=[];function b(r){return(0,t.jsxs)(s.A,{groupId:"language",children:[(0,t.jsx)(o.A,{value:"C",children:(0,t.jsx)(l.A,{language:"c",title:"src/c/arrays-pointers/01-array-basics.c",showLineNumbers:!0,children:u})}),(0,t.jsx)(o.A,{value:"C++",children:(0,t.jsx)(l.A,{language:"cpp",title:"src/cpp/arrays-pointers/01-array-basics.cpp",showLineNumbers:!0,children:c})})]})}function h(r={}){const{wrapper:n}={...(0,i.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(b,{...r})}):b()}},9365:(r,n,e)=>{e.d(n,{A:()=>s});e(6540);var a=e(4164);const t={tabItem:"tabItem_Ymn6"};var i=e(4848);function s(r){let{children:n,hidden:e,className:s}=r;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(t.tabItem,s),hidden:e,children:n})}},1470:(r,n,e)=>{e.d(n,{A:()=>I});var a=e(6540),t=e(4164),i=e(3104),s=e(6347),o=e(205),l=e(7485),u=e(1682),c=e(679);function d(r){return a.Children.toArray(r).filter((r=>"\n"!==r)).map((r=>{if(!r||(0,a.isValidElement)(r)&&function(r){const{props:n}=r;return!!n&&"object"==typeof n&&"value"in n}(r))return r;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof r.type?r.type:r.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(r){const{values:n,children:e}=r;return(0,a.useMemo)((()=>{const r=n??function(r){return d(r).map((r=>{let{props:{value:n,label:e,attributes:a,default:t}}=r;return{value:n,label:e,attributes:a,default:t}}))}(e);return function(r){const n=(0,u.XI)(r,((r,n)=>r.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((r=>r.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(r),r}),[n,e])}function m(r){let{value:n,tabValues:e}=r;return e.some((r=>r.value===n))}function f(r){let{queryString:n=!1,groupId:e}=r;const t=(0,s.W6)(),i=function(r){let{queryString:n=!1,groupId:e}=r;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,l.aZ)(i),(0,a.useCallback)((r=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,r),t.replace({...t.location,search:n.toString()})}),[i,t])]}function b(r){const{defaultValue:n,queryString:e=!1,groupId:t}=r,i=p(r),[s,l]=(0,a.useState)((()=>function(r){let{defaultValue:n,tabValues:e}=r;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((r=>r.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=e.find((r=>r.default))??e[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[u,d]=f({queryString:e,groupId:t}),[b,h]=function(r){let{groupId:n}=r;const e=function(r){return r?`docusaurus.tab.${r}`:null}(n),[t,i]=(0,c.Dv)(e);return[t,(0,a.useCallback)((r=>{e&&i.set(r)}),[e,i])]}({groupId:t}),y=(()=>{const r=u??b;return m({value:r,tabValues:i})?r:null})();(0,o.A)((()=>{y&&l(y)}),[y]);return{selectedValue:s,selectValue:(0,a.useCallback)((r=>{if(!m({value:r,tabValues:i}))throw new Error(`Can't select invalid tab value=${r}`);l(r),d(r),h(r)}),[d,h,i]),tabValues:i}}var h=e(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=e(4848);function g(r){let{className:n,block:e,selectedValue:a,selectValue:s,tabValues:o}=r;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,i.a_)(),c=r=>{const n=r.currentTarget,e=l.indexOf(n),t=o[e].value;t!==a&&(u(n),s(t))},d=r=>{let n=null;switch(r.key){case"Enter":c(r);break;case"ArrowRight":{const e=l.indexOf(r.currentTarget)+1;n=l[e]??l[0];break}case"ArrowLeft":{const e=l.indexOf(r.currentTarget)-1;n=l[e]??l[l.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":e},n),children:o.map((r=>{let{value:n,label:e,attributes:i}=r;return(0,v.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:r=>l.push(r),onKeyDown:d,onClick:c,...i,className:(0,t.A)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":a===n}),children:e??n},n)}))})}function w(r){let{lazy:n,children:e,selectedValue:i}=r;const s=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const r=s.find((r=>r.props.value===i));return r?(0,a.cloneElement)(r,{className:(0,t.A)("margin-top--md",r.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map(((r,n)=>(0,a.cloneElement)(r,{key:n,hidden:r.props.value!==i})))})}function _(r){const n=b(r);return(0,v.jsxs)("div",{className:(0,t.A)("tabs-container",y.tabList),children:[(0,v.jsx)(g,{...n,...r}),(0,v.jsx)(w,{...n,...r})]})}function I(r){const n=(0,h.A)();return(0,v.jsx)(_,{...r,children:d(r.children)},String(n))}}}]);