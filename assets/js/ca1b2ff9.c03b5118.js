"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[6630],{5162:(e,r,n)=>{n.d(r,{Z:()=>s});var a=n(7294),t=n(6010);const i="tabItem_Ymn6";function s(e){let{children:r,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,t.Z)(i,s),hidden:n},r)}},4866:(e,r,n)=>{n.d(r,{Z:()=>_});var a=n(7462),t=n(7294),i=n(6010),s=n(2466),o=n(6550),u=n(1980),l=n(7392),c=n(12);function d(e){return function(e){return t.Children.map(e,(e=>{if((0,t.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:r,label:n,attributes:a,default:t}}=e;return{value:r,label:n,attributes:a,default:t}}))}function p(e){const{values:r,children:n}=e;return(0,t.useMemo)((()=>{const e=r??d(n);return function(e){const r=(0,l.l)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,n])}function m(e){let{value:r,tabValues:n}=e;return n.some((e=>e.value===r))}function f(e){let{queryString:r=!1,groupId:n}=e;const a=(0,o.k6)(),i=function(e){let{queryString:r=!1,groupId:n}=e;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:r,groupId:n});return[(0,u._X)(i),(0,t.useCallback)((e=>{if(!i)return;const r=new URLSearchParams(a.location.search);r.set(i,e),a.replace({...a.location,search:r.toString()})}),[i,a])]}function y(e){const{defaultValue:r,queryString:n=!1,groupId:a}=e,i=p(e),[s,o]=(0,t.useState)((()=>function(e){let{defaultValue:r,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!m({value:r,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${r}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return r}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:r,tabValues:i}))),[u,l]=f({queryString:n,groupId:a}),[d,y]=function(e){let{groupId:r}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(r),[a,i]=(0,c.Nk)(n);return[a,(0,t.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),b=(()=>{const e=u??d;return m({value:e,tabValues:i})?e:null})();(0,t.useEffect)((()=>{b&&o(b)}),[b]);return{selectedValue:s,selectValue:(0,t.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),l(e),y(e)}),[l,y,i]),tabValues:i}}var b=n(2389);const h="tabList__CuJ",v="tabItem_LNqP";function g(e){let{className:r,block:n,selectedValue:o,selectValue:u,tabValues:l}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=e=>{const r=e.currentTarget,n=c.indexOf(r),a=l[n].value;a!==o&&(d(r),u(a))},m=e=>{let r=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;r=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;r=c[n]??c[c.length-1];break}}r?.focus()};return t.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},r)},l.map((e=>{let{value:r,label:n,attributes:s}=e;return t.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===r?0:-1,"aria-selected":o===r,key:r,ref:e=>c.push(e),onKeyDown:m,onClick:p},s,{className:(0,i.Z)("tabs__item",v,s?.className,{"tabs__item--active":o===r})}),n??r)})))}function k(e){let{lazy:r,children:n,selectedValue:a}=e;if(r){const e=n.find((e=>e.props.value===a));return e?(0,t.cloneElement)(e,{className:"margin-top--md"}):null}return t.createElement("div",{className:"margin-top--md"},n.map(((e,r)=>(0,t.cloneElement)(e,{key:r,hidden:e.props.value!==a}))))}function w(e){const r=y(e);return t.createElement("div",{className:(0,i.Z)("tabs-container",h)},t.createElement(g,(0,a.Z)({},e,r)),t.createElement(k,(0,a.Z)({},e,r)))}function _(e){const r=(0,b.Z)();return t.createElement(w,(0,a.Z)({key:String(r)},e))}},5350:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>l,default:()=>f,frontMatter:()=>u,metadata:()=>c,toc:()=>p});var a=n(7462),t=(n(7294),n(3905)),i=n(4866),s=n(5162),o=n(814);const u={title:"Array basics"},l=void 0,c={unversionedId:"arrays-pointers/array-basics",id:"arrays-pointers/array-basics",title:"Array basics",description:"",source:"@site/docs/arrays-pointers/array-basics.mdx",sourceDirName:"arrays-pointers",slug:"/arrays-pointers/array-basics",permalink:"/c-cpp/arrays-pointers/array-basics",draft:!1,editUrl:"https://github.com/pranabdas/c-cpp/blob/main/docs/arrays-pointers/array-basics.mdx",tags:[],version:"current",frontMatter:{title:"Array basics"},sidebar:"docs",previous:{title:"Array and Pointer",permalink:"/c-cpp/category/array-and-pointer"},next:{title:"Pointer basics",permalink:"/c-cpp/arrays-pointers/pointer-basics"}},d={},p=[],m={toc:p};function f(e){let{components:r,...n}=e;return(0,t.kt)("wrapper",(0,a.Z)({},m,n,{components:r,mdxType:"MDXLayout"}),(0,t.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,t.kt)(s.Z,{value:"C",mdxType:"TabItem"},(0,t.kt)(o.Z,{language:"c",title:"src/c/arrays-pointers/01-array-basics.c",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <stdio.h>\n\nint main()\n{\n    const int SIZE = 5;\n\n    // int array1[SIZE] = {0}; // if the array size is not knowns compile time,\n                            // use heap dynamic memory\n    // int array2[SIZE] = {1, 2, 3, 4, 5};\n    // some compiler might complain here, use 5 instead of SIZE\n    // fails in gcc, however works in apple clang\n    int array1[5] = {0};\n    int array2[5] = {1, 2, 3, 4, 5};\n    int array3[] = {1, 2, 3, 4, 5};\n\n    char str1[] = "hello";\n\n    int i;\n    double sum2 = 0, sum3 = 0;\n    double *ptr_sum2 = &sum2;\n\n    for (i = 0; i < SIZE; i++)\n    {\n        sum2 += array2[i];\n        sum3 += array3[i];\n    }\n\n    printf("Sum2 = %f\\n", sum2);\n    printf("Sum3 = %f\\n", sum3);\n\n    printf("Pointer sum2: %p\\n", ptr_sum2);\n    printf("Sum2 = %f\\n", *ptr_sum2);\n\n    printf("array2 position: %p\\n", array2);\n\n    return 0;\n}\n')),(0,t.kt)(s.Z,{value:"C++",mdxType:"TabItem"},(0,t.kt)(o.Z,{language:"cpp",title:"src/cpp/arrays-pointers/01-array-basics.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <iostream>\nusing namespace std;\n\nvoid print_2d_array(float *, int, int);\n\nint main()\n{\n    int arr[] = {2, 4, 8, 15};\n    // arr[4] = {1, 2};\n    // above assignment sets: arr[0] = 1, arr[1] = 2, arr[2] = 0, arr[3] = 0\n    // aggregation initialization:\n    // note that if we do not provide any value via curly braces, the array\n    // remains uninitialized. To make sure array is initialized to zeros:\n    // arr[4] = {}\n\n    for (int i : arr)\n    {\n        cout << i << endl;\n    }\n\n    const int SIZE = 10; // `const` is necessary here\n    double data[SIZE];\n    // if the size of array is not known compile time, use heap dynamic array\n\n    cout << "Size of data = " << sizeof(data) << " bytes\\n";\n    cout << "Length of data array: " << sizeof(data) / sizeof(data[0]) << endl;\n    // the above prints the size of the entire array\n\n    // multi-dimensional array:\n    float arr2d[3][4] = {0.0}; // this initializes all elements to with 0.0\n    cout << "\\narr2d:\\n";\n    print_2d_array(&arr2d[0][0], 3, 4);\n\n    float arr2d2[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    cout << "\\narr2d2:\\n";\n    print_2d_array(&arr2d2[0][0], 3, 4);\n\n    float arr2d3[3][4] = {{1.1, 2.2, 3.3, 4.4},\n                          {5.5, 6.6, 7.7, 8.8},\n                          {9.9, 10., 11., 12.}};\n    cout << "\\narr2d3:\\n";\n    print_2d_array(&arr2d3[0][0], 3, 4);\n\n    float arr2d4[][4] = {{1.1, 2.2, 3.3, 4.4},\n                          {5.5, 6.6, 7.7, 8.8},\n                          {9.9, 10., 11., 12.}};\n    cout << "\\narr2d4:\\n";\n    print_2d_array(&arr2d4[0][0], 3, 4);\n\n    float arr2d5[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    cout << "\\narr2d5:\\n";\n    print_2d_array(&arr2d5[0][0], 3, 4);\n\n    float arr2d6[3][4] = {0.3}; // sets first element to 0.3, rest to 0.0\n    cout << "\\narr2d6:\\n";\n    print_2d_array(&arr2d6[0][0], 3, 4);\n\n    return 0;\n}\n\nvoid print_2d_array(float *arr, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            // array elements are continuously stored row by row in C++\n            cout << *(arr + (n * i) + j) << "\\t";\n            //      |   --- pointer to the first element, do the pointer\n            //      |       arithmetic to get the next elements\n            //      dereference the value\n        }\n        cout << endl;\n    }\n}\n'))))}f.isMDXComponent=!0}}]);