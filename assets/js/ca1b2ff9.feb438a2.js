"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[630],{5162:(e,a,n)=>{n.d(a,{Z:()=>i});var r=n(7294),t=n(6010);const s="tabItem_Ymn6";function i(e){let{children:a,hidden:n,className:i}=e;return r.createElement("div",{role:"tabpanel",className:(0,t.Z)(s,i),hidden:n},a)}},5488:(e,a,n)=>{n.d(a,{Z:()=>d});var r=n(7462),t=n(7294),s=n(6010),i=n(2389),o=n(7392),l=n(7094),u=n(2466);const c="tabList__CuJ",p="tabItem_LNqP";function m(e){var a;const{lazy:n,block:i,defaultValue:m,values:d,groupId:b,className:y}=e,f=t.Children.map(e.children,(e=>{if((0,t.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),h=d??f.map((e=>{let{props:{value:a,label:n,attributes:r}}=e;return{value:a,label:n,attributes:r}})),v=(0,o.l)(h,((e,a)=>e.value===a.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===m?m:m??(null==(a=f.find((e=>e.props.default)))?void 0:a.props.value)??f[0].props.value;if(null!==g&&!h.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${h.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:T}=(0,l.U)(),[Z,w]=(0,t.useState)(g),E=[],{blockElementScrollPositionUntilNextRender:I}=(0,u.o5)();if(null!=b){const e=k[b];null!=e&&e!==Z&&h.some((a=>a.value===e))&&w(e)}const S=e=>{const a=e.currentTarget,n=E.indexOf(a),r=h[n].value;r!==Z&&(I(a),w(r),null!=b&&T(b,String(r)))},x=e=>{var a;let n=null;switch(e.key){case"ArrowRight":{const a=E.indexOf(e.currentTarget)+1;n=E[a]??E[0];break}case"ArrowLeft":{const a=E.indexOf(e.currentTarget)-1;n=E[a]??E[E.length-1];break}}null==(a=n)||a.focus()};return t.createElement("div",{className:(0,s.Z)("tabs-container",c)},t.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":i},y)},h.map((e=>{let{value:a,label:n,attributes:i}=e;return t.createElement("li",(0,r.Z)({role:"tab",tabIndex:Z===a?0:-1,"aria-selected":Z===a,key:a,ref:e=>E.push(e),onKeyDown:x,onFocus:S,onClick:S},i,{className:(0,s.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":Z===a})}),n??a)}))),n?(0,t.cloneElement)(f.filter((e=>e.props.value===Z))[0],{className:"margin-top--md"}):t.createElement("div",{className:"margin-top--md"},f.map(((e,a)=>(0,t.cloneElement)(e,{key:a,hidden:e.props.value!==Z})))))}function d(e){const a=(0,i.Z)();return t.createElement(m,(0,r.Z)({key:String(a)},e))}},5350:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>p,contentTitle:()=>u,default:()=>b,frontMatter:()=>l,metadata:()=>c,toc:()=>m});var r=n(7462),t=(n(7294),n(3905)),s=n(5488),i=n(5162),o=n(814);const l={title:"Array basics"},u=void 0,c={unversionedId:"arrays-pointers/array-basics",id:"arrays-pointers/array-basics",title:"Array basics",description:"",source:"@site/docs/arrays-pointers/array-basics.mdx",sourceDirName:"arrays-pointers",slug:"/arrays-pointers/array-basics",permalink:"/c-cpp/arrays-pointers/array-basics",draft:!1,editUrl:"https://github.com/pranabdas/c-cpp/blob/main/docs/arrays-pointers/array-basics.mdx",tags:[],version:"current",frontMatter:{title:"Array basics"},sidebar:"docs",previous:{title:"Array and Pointer",permalink:"/c-cpp/category/array-and-pointer"},next:{title:"Pointer basics",permalink:"/c-cpp/arrays-pointers/pointer-basics"}},p={},m=[],d={toc:m};function b(e){let{components:a,...n}=e;return(0,t.kt)("wrapper",(0,r.Z)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,t.kt)(s.Z,{groupId:"language",mdxType:"Tabs"},(0,t.kt)(i.Z,{value:"C",mdxType:"TabItem"},(0,t.kt)(o.Z,{language:"c",title:"src/c/arrays-pointers/01-array-basics.c",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <stdio.h>\n\nint main()\n{\n    const int SIZE = 5;\n\n    // int array1[SIZE] = {0}; // if the array size is not knowns compile time,\n                            // use heap dynamic memory\n    // int array2[SIZE] = {1, 2, 3, 4, 5};\n    // some compiler might complain here, use 5 instead of SIZE\n    // fails in gcc, however works in apple clang\n    int array1[5] = {0};\n    int array2[5] = {1, 2, 3, 4, 5};\n    int array3[] = {1, 2, 3, 4, 5};\n\n    char str1[] = "hello";\n\n    int i;\n    double sum2 = 0, sum3 = 0;\n    double *ptr_sum2 = &sum2;\n\n    for (i = 0; i < SIZE; i++)\n    {\n        sum2 += array2[i];\n        sum3 += array3[i];\n    }\n\n    printf("Sum2 = %f\\n", sum2);\n    printf("Sum3 = %f\\n", sum3);\n\n    printf("Pointer sum2: %p\\n", ptr_sum2);\n    printf("Sum2 = %f\\n", *ptr_sum2);\n\n    printf("array2 position: %p\\n", array2);\n\n    return 0;\n}\n')),(0,t.kt)(i.Z,{value:"C++",mdxType:"TabItem"},(0,t.kt)(o.Z,{language:"cpp",title:"src/cpp/arrays-pointers/01-array-basics.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int arr[] = {2, 4, 8, 15};\n    // arr[4] = {1, 2};\n    // above assignment sets: arr[0] = 1, arr[1] = 2, arr[2] = 0, arr[3] = 0\n    // aggregation initialization:\n    // note that if we do not provide any value via curly braces, the array\n    // remains uninitialized. To make sure array is initialized to zeros:\n    // arr[4] = {}\n\n    // multi-dimensional array: float arr2d[3][4];\n\n    for (int i : arr)\n    {\n        cout << i << endl;\n    }\n\n    const int SIZE = 10; // `const` is necessary here\n    double data[SIZE];\n    // if the size of array is not known compile time, use heap dynamic array\n\n    cout << "Size of data = " << sizeof(data) << " bytes\\n";\n    // the above prints the size of the entire array\n\n    return 0;\n}\n'))))}b.isMDXComponent=!0}}]);