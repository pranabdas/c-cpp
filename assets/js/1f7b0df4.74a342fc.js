"use strict";(self.webpackChunkc_cpp=self.webpackChunkc_cpp||[]).push([[3732],{5162:(n,e,t)=>{t.d(e,{Z:()=>u});var i=t(7294),a=t(6010);const r="tabItem_Ymn6";function u(n){let{children:e,hidden:t,className:u}=n;return i.createElement("div",{role:"tabpanel",className:(0,a.Z)(r,u),hidden:t},e)}},4866:(n,e,t)=>{t.d(e,{Z:()=>T});var i=t(7462),a=t(7294),r=t(6010),u=t(2466),o=t(6550),l=t(1980),s=t(7392),c=t(12);function d(n){return function(n){return a.Children.map(n,(n=>{if((0,a.isValidElement)(n)&&"value"in n.props)return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(n).map((n=>{let{props:{value:e,label:t,attributes:i,default:a}}=n;return{value:e,label:t,attributes:i,default:a}}))}function p(n){const{values:e,children:t}=n;return(0,a.useMemo)((()=>{const n=e??d(t);return function(n){const e=(0,s.l)(n,((n,e)=>n.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((n=>n.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n}),[e,t])}function f(n){let{value:e,tabValues:t}=n;return t.some((n=>n.value===e))}function m(n){let{queryString:e=!1,groupId:t}=n;const i=(0,o.k6)(),r=function(n){let{queryString:e=!1,groupId:t}=n;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l._X)(r),(0,a.useCallback)((n=>{if(!r)return;const e=new URLSearchParams(i.location.search);e.set(r,n),i.replace({...i.location,search:e.toString()})}),[r,i])]}function b(n){const{defaultValue:e,queryString:t=!1,groupId:i}=n,r=p(n),[u,o]=(0,a.useState)((()=>function(n){let{defaultValue:e,tabValues:t}=n;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!f({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((n=>n.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=t.find((n=>n.default))??t[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:e,tabValues:r}))),[l,s]=m({queryString:t,groupId:i}),[d,b]=function(n){let{groupId:e}=n;const t=function(n){return n?`docusaurus.tab.${n}`:null}(e),[i,r]=(0,c.Nk)(t);return[i,(0,a.useCallback)((n=>{t&&r.set(n)}),[t,r])]}({groupId:i}),g=(()=>{const n=l??d;return f({value:n,tabValues:r})?n:null})();(0,a.useEffect)((()=>{g&&o(g)}),[g]);return{selectedValue:u,selectValue:(0,a.useCallback)((n=>{if(!f({value:n,tabValues:r}))throw new Error(`Can't select invalid tab value=${n}`);o(n),s(n),b(n)}),[s,b,r]),tabValues:r}}var g=t(2389);const h="tabList__CuJ",v="tabItem_LNqP";function y(n){let{className:e,block:t,selectedValue:o,selectValue:l,tabValues:s}=n;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,u.o5)(),p=n=>{const e=n.currentTarget,t=c.indexOf(e),i=s[t].value;i!==o&&(d(e),l(i))},f=n=>{let e=null;switch(n.key){case"Enter":p(n);break;case"ArrowRight":{const t=c.indexOf(n.currentTarget)+1;e=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(n.currentTarget)-1;e=c[t]??c[c.length-1];break}}e?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},e)},s.map((n=>{let{value:e,label:t,attributes:u}=n;return a.createElement("li",(0,i.Z)({role:"tab",tabIndex:o===e?0:-1,"aria-selected":o===e,key:e,ref:n=>c.push(n),onKeyDown:f,onClick:p},u,{className:(0,r.Z)("tabs__item",v,u?.className,{"tabs__item--active":o===e})}),t??e)})))}function k(n){let{lazy:e,children:t,selectedValue:i}=n;if(e){const n=t.find((n=>n.props.value===i));return n?(0,a.cloneElement)(n,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},t.map(((n,e)=>(0,a.cloneElement)(n,{key:e,hidden:n.props.value!==i}))))}function w(n){const e=b(n);return a.createElement("div",{className:(0,r.Z)("tabs-container",h)},a.createElement(y,(0,i.Z)({},n,e)),a.createElement(k,(0,i.Z)({},n,e)))}function T(n){const e=(0,g.Z)();return a.createElement(w,(0,i.Z)({key:String(e)},n))}},25:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var i=t(7462),a=(t(7294),t(3905)),r=t(4866),u=t(5162),o=t(814);const l={title:"Function"},s=void 0,c={unversionedId:"basics/function",id:"basics/function",title:"Function",description:"Function prototype",source:"@site/docs/basics/function.mdx",sourceDirName:"basics",slug:"/basics/function",permalink:"/c-cpp/basics/function",draft:!1,editUrl:"https://github.com/pranabdas/c-cpp/blob/main/docs/basics/function.mdx",tags:[],version:"current",frontMatter:{title:"Function"},sidebar:"docs",previous:{title:"Loop",permalink:"/c-cpp/basics/loop"},next:{title:"Recursion",permalink:"/c-cpp/basics/recursion"}},d={},p=[{value:"Function prototype",id:"function-prototype",level:2},{value:"Call by reference",id:"call-by-reference",level:2},{value:"Inline function",id:"inline-function",level:2},{value:"Default arguments",id:"default-arguments",level:2},{value:"Function overloading",id:"function-overloading",level:2}],f={toc:p};function m(n){let{components:e,...t}=n;return(0,a.kt)("wrapper",(0,i.Z)({},f,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,a.kt)(u.Z,{value:"C",mdxType:"TabItem"},(0,a.kt)(o.Z,{language:"c",title:"src/c/basics/05-circle-area.c",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <stdio.h>\n\n#define PI 3.14159\n// preprocessor statement: it tells the compiler to replace instances of PI with\n// its defined value\n\nint main()\n{\n    double area = 0.0;\n    double radius = 0.0;\n    printf("Enter radius: ");\n    scanf("%lf", &radius);\n\n    area = PI * radius * radius;\n    printf("Area of circle = %lf\\n", area);\n}\n\n/*=============================================================================\nTest 1:\nradius = 1\narea = 3.14159\n=============================================================================*/\n')),(0,a.kt)(u.Z,{value:"C++",mdxType:"TabItem"},(0,a.kt)(o.Z,{language:"cpp",title:"src/cpp/basics/05-deg-c-f.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <iostream>\nusing namespace std;\n\nint main()\n{\n    float degC;\n    cout << "Enter value in deg C: ";\n    cin >> degC;\n\n    float degF;\n    degF = (9.0 / 5) * degC + 32;\n    // notice 9/5 would result in integer division give 1\n    // degF = (static_cast<float>(9) / 5) * degC + 32;\n    // degF = (float) 9 / 5 * degC + 32;\n\n    cout << degC << " deg C = " << degF << " deg F" << endl;\n    return 0;\n}\n'))),(0,a.kt)("h2",{id:"function-prototype"},"Function prototype"),(0,a.kt)("p",null,"Prototype declaration can help with code organization. We can declare function\nprototype in the top of the file followed by main function, and finally place\nthe body of prototyped functions in the bottom."),(0,a.kt)(o.Z,{language:"c",title:"src/c/basics/05-function-proto.c",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <stdio.h>\n\n// prototype declaration\nfloat add(float, float);  \n// float add(float input1, float input2);\n\nint main()\n{\n    float input1, input2, sum;\n    printf("Enter input 1: ");\n    scanf("%f", &input1);\n    printf("Enter input 2: ");\n    scanf("%f", &input2);\n\n    sum = add(input1, input2);\n\n    printf("Total = %f\\n", sum);\n\n    return 0;\n}\n\n// function definition can be placed after main()\nfloat add(float input1, float input2)\n{\n    return (input1 + input2);\n}\n'),(0,a.kt)("h2",{id:"call-by-reference"},"Call by reference"),(0,a.kt)("p",null,"We can call by reference in order to update the values in the calling\nenvironment instead of returning function values. Here is an example in C++:"),(0,a.kt)(o.Z,{language:"cpp",title:"src/cpp/basics/05-func-call-by-ref.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'// this program takes an integer input and prints number of digits in the given\n// input and sum of the digits. For example, an input of 1235 would print 4 and\n// 11. If we have to implement a function, we need to return two results. One of\n// the ways we can achieve this by implementing a function with call by\n// reference\n#include <iostream>\nusing namespace std;\n\nvoid analyze_digits(int, int &, int &);\n\nint main()\n{\n    int num, num_digits, sum_digits;\n    cout << "Enter integer input: ";\n    cin >> num;\n\n    analyze_digits(num, num_digits, sum_digits);\n\n    cout << "Number of digits: " << num_digits << endl;\n    cout << "Sum of digits: " << sum_digits << endl;\n\n    return 0;\n}\n\nvoid analyze_digits(int num, int &num_digits, int &sum_digits)\n{\n    int digits = 0;\n    int sum = 0;\n\n    while (num > 0)\n    {\n        digits += 1;\n        sum += num % 10;\n        num = num / 10;\n    }\n\n    num_digits = digits;\n    sum_digits = sum;\n}\n'),(0,a.kt)("p",null,"We can achieve the same using pointer as well, however syntax could be little\ndifficult (I think):"),(0,a.kt)(o.Z,{language:"c",title:"src/c/basics/05-using-swap-pointer.c",showLineNumbers:!0,mdxType:"CodeBlock"},'#include <stdio.h>\n\nvoid swap(int *i, int *j)\n{\n    int temp = *i;\n    *i = *j;\n    *j = temp;\n}\n\nint main()\n{\n    int a = 3, b = 5;\n\n    printf("Before swap: a = %d, b = %d\\n", a, b);\n    swap(&a, &b);\n    printf("After swap: a = %d, b = %d\\n", a, b);\n    return 0;\n}\n'),(0,a.kt)("h2",{id:"inline-function"},"Inline function"),(0,a.kt)("p",null,"Inline function blocks are copied to the calling environment, instead of calling\nenvironment handling over control to the function. This reduces function call\noverheads, suitable for functions with minimal computation."),(0,a.kt)(o.Z,{language:"cpp",title:"src/cpp/basics/05-func-inline.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},"// inline functions are just copied to the where they are called\n// useful for small functions, function calls have some overhead due to stack\n// calls\n#include <iostream>\nusing namespace std;\n\ninline int make_double(int);\n\nint main()\n{\n    int size = 3;\n    cout << make_double(size) << endl;\n\n    return 0;\n}\n\nint make_double(int size)\n{\n    return (2 * size);\n}\n"),(0,a.kt)("h2",{id:"default-arguments"},"Default arguments"),(0,a.kt)(o.Z,{language:"cpp",title:"src/cpp/basics/05-func-default-args.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},"#include <iostream>\nusing namespace std;\n\n// int vol(int, int width=1, int height=1);\nint vol(int, int = 1, int = 1);\n\nint main()\n{\n    cout << vol(1) << endl;\n    cout << vol(3, 2, 2) << endl;\n    return 0;\n}\n\nint vol(int length, int width, int height)\n{\n    return (length * width * height);\n}\n"),(0,a.kt)("h2",{id:"function-overloading"},"Function overloading"),(0,a.kt)(o.Z,{language:"cpp",title:"src/cpp/basics/05-func-overloading.cpp",showLineNumbers:!0,mdxType:"CodeBlock"},'// multiple functions can have same name provided they have different numbers of\n// arguments or different argument type. function signature not only on their\n// names but also on arguments\n#include <iostream>\nusing namespace std;\n\nint add(int a, int b)\n{\n    return (a + b);\n}\n\nint add(int a, int b, int c)\n{\n    return (a + b + c);\n}\n\nfloat add(float a, float b)\n{\n    return (a + b);\n}\n\nint main()\n{\n    int a = 2, b = 4, c = 5;\n    float d = 3.2, e = 4.5;\n\n    cout << a << " + " << b << " = " << add(a, b) << endl;\n    cout << a << " + " << b << " + " << c << " = " << add(a, b, c) << endl;\n    cout << d << " + " << e << " = " << add(d, e) << endl;\n\n    return 0;\n}\n'))}m.isMDXComponent=!0}}]);